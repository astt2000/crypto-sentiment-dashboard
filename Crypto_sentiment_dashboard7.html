<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Crypto Sentiment Dashboard v12 ‚Äî Ultra Compact</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<style>
  :root{
    --bg:#f6f9fb; --card:#ffffff; --text:#0e1720; --muted:#65707a; --accent:#0b76d1;
    --green-tint: rgba(29,161,84,0.08);
    --red-tint: rgba(214,69,58,0.08);
    --hold-tint: rgba(66,133,244,0.06);
    --dark-bg:#071217; --dark-card:#0b1216; --dark-text:#e6eef6;
    --pad:8px; --gap:6px; --radius:8px; --card-font:13px;
    font-family: Inter, "Segoe UI", Roboto, Arial, sans-serif;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);-webkit-font-smoothing:antialiased}
  body.dark{background:var(--dark-bg);color:var(--dark-text)}

  .app{max-width:960px;margin:0 auto;padding:8px;}
  header{display:flex;align-items:center;justify-content:space-between;padding:6px;border-radius:8px;position:sticky;top:0;z-index:20;background:rgba(255,255,255,0.9)}
  body.dark header{background:rgba(6,10,12,0.6)}
  .brand{display:flex;gap:8px;align-items:center}
  .brand h1{margin:0;font-size:0.98rem;font-weight:800;color:var(--accent)}
  .controls{display:flex;gap:6px;align-items:center}
  select,button,input{font-weight:700;border:0;cursor:pointer;border-radius:8px}
  .btn-primary{background:var(--accent);color:#fff;padding:6px 8px}
  .btn-ghost{background:transparent;padding:6px 8px;border:1px solid rgba(0,0,0,0.06)}
  body.dark .btn-ghost{border:1px solid rgba(255,255,255,0.06)}

  .sentiment{margin:8px 0;text-align:center}
  #sentScore{font-weight:800;font-size:0.98rem}
  .bar{width:100%;height:10px;border-radius:999px;background:linear-gradient(90deg,#7db9e8,#f2c94c,#e5534b);position:relative;margin-top:8px}
  .pointer{position:absolute;top:-6px;width:6px;height:22px;border-radius:3px;background:#111;transform:translateX(-50%);transition:left .8s}
  body.dark .pointer{background:#fff}

  .main-chart{height:120px;margin-top:6px;margin-bottom:6px}

  .grid{display:grid;grid-template-columns:repeat(3,1fr);gap:6px}
  .card{background:var(--card);border-radius:var(--radius);padding:8px;min-height:80px;box-shadow:0 6px 18px rgba(16,24,40,0.04);font-size:var(--card-font)}
  body.dark .card{background:var(--dark-card);box-shadow:none}
  .label{display:flex;justify-content:space-between;align-items:center;font-weight:800;color:var(--accent);font-size:13px}
  .value{font-weight:800;font-size:14px;margin-top:6px}
  .conf{font-size:11px;color:var(--muted);margin-left:6px}
  .chip{display:inline-block;padding:4px 8px;border-radius:999px;font-weight:800;font-size:12px;margin-top:6px}
  .chip.buy{background:transparent;color: #1e8a3f; border:1px solid rgba(30,138,63,0.12)}
  .chip.hold{background:transparent;color:#65707a;border:1px solid rgba(101,112,122,0.08)}
  .chip.sell{background:transparent;color:#d6453a;border:1px solid rgba(214,69,58,0.08)}
  .meaning, .insight{font-size:12px;color:var(--muted);margin-top:6px;line-height:1.14}
  .meaning b, .insight b{font-weight:700;color:inherit}

  /* color card tints */
  .card.buy-bg{background:linear-gradient(180deg,var(--green-tint),rgba(255,255,255,0));}
  .card.sell-bg{background:linear-gradient(180deg,var(--red-tint),rgba(255,255,255,0));}
  .card.hold-bg{background:linear-gradient(180deg,var(--hold-tint),rgba(255,255,255,0));}

  .detail{font-size:12px;color:var(--muted);margin-top:6px;border-top:1px dashed rgba(0,0,0,0.04);padding-top:6px}
  body.dark .detail{border-top-color:rgba(255,255,255,0.04)}

  .summary{margin-top:8px;border-radius:8px;padding:6px;background:rgba(0,0,0,0.02);font-size:13px}
  body.dark .summary{background:rgba(255,255,255,0.02)}
  .summary-row{display:flex;justify-content:space-between;gap:8px;padding:4px 6px;border-radius:6px;font-weight:700}
  .summary-row.buy{background:rgba(29,161,84,0.06);color:#1e8a3f}
  .summary-row.sell{background:rgba(214,69,58,0.06);color:#d6453a}
  .summary-row.hold{color:var(--muted)}

  .settings-toggle{display:flex;justify-content:center;margin:10px 0}
  .settings-panel{background:var(--card);border-radius:8px;padding:8px;margin-top:6px;box-shadow:0 6px 18px rgba(16,24,40,0.04)}
  body.dark .settings-panel{background:var(--dark-card);box-shadow:none}
  .settings-row{display:flex;align-items:center;gap:8px;padding:6px 0;border-bottom:1px solid rgba(0,0,0,0.03)}
  .settings-row label{min-width:170px;font-weight:700;font-size:13px}
  .small{font-size:12px;color:var(--muted)}

  #timestamp{font-size:12px;color:var(--muted);text-align:center;margin-top:8px}

  @media(max-width:900px){ .grid{grid-template-columns:repeat(2,1fr)} .label{font-size:13px} }
  @media(max-width:640px){
    .grid{grid-template-columns:1fr}
    header{padding:6px}
    .brand h1{font-size:0.96rem}
    .label{font-size:14px}
    .value{font-size:15px}
    .settings-row label{min-width:110px;font-size:13px}
  }
</style>
</head>
<body>
  <div class="app">
    <header>
      <div class="brand">
        <svg width="30" height="30" viewBox="0 0 24 24" aria-hidden><rect width="24" height="24" rx="5" fill="#0b76d1"/><path d="M5 15l3-6 3 12 3-9 3 6" stroke="#fff" stroke-width="1.1" stroke-linecap="round" stroke-linejoin="round"/></svg>
        <h1>Crypto Sentiment ‚Äî v12 (Ultra Compact)</h1>
      </div>

      <div class="controls">
        <select id="refresh"><option value="5">5m</option><option value="10" selected>10m</option><option value="30">30m</option></select>
        <button id="darkToggle" class="btn-ghost" title="Toggle theme">üåô</button>
        <button id="refreshNow" class="btn-primary" title="Refresh now">‚Üª</button>
      </div>
    </header>

    <div id="alertArea" aria-live="polite"></div>

    <section class="sentiment" aria-live="polite">
      <div id="sentScore">Loading‚Ä¶</div>
      <div class="bar"><div id="ptr" class="pointer" style="left:50%"></div></div>
    </section>

    <div class="main-chart" style="height:120px"><canvas id="mainChart" style="width:100%;height:100%"></canvas></div>

    <section id="cards" class="grid" aria-live="polite"></section>

    <div id="summary" class="summary" style="display:none" aria-live="polite"></div>

    <div id="timestamp">‚è∞ Last updated: -- (Malaysia GMT+8)</div>

    <div class="settings-toggle">
      <button id="settingsToggle" class="btn-ghost">‚öôÔ∏è Adjust Indicator Settings</button>
    </div>

    <div id="settingsPanel" class="settings-panel" style="display:none;">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div><strong>Indicator Settings & Weights</strong> <span class="small">(saved locally)</span></div>
        <div style="display:flex;gap:8px">
          <button id="resetDefaults" class="btn-ghost">Reset defaults</button>
          <button id="closeSettings" class="btn-primary">Done</button>
        </div>
      </div>
      <div id="settingsContent" style="margin-top:8px"></div>
    </div>

  </div>

<script>
/* ----------------------------
   Utilities & safeFetch
   ---------------------------- */
async function safeFetch(url, timeout=9000){
  try{
    const ctrl = new AbortController();
    const id = setTimeout(()=>ctrl.abort(), timeout);
    const res = await fetch(url, { signal: ctrl.signal });
    clearTimeout(id);
    if(!res.ok) throw new Error(res.status + ' ' + res.statusText);
    return await res.json();
  }catch(e){ console.warn('Fetch failed', url, e && e.message); return null; }
}
function fmtNum(v){ if(v===null||v===undefined||isNaN(v)) return 'N/A'; if(Math.abs(v)>=1e12) return (v/1e12).toFixed(2)+'T'; if(Math.abs(v)>=1e9) return (v/1e9).toFixed(2)+'B'; if(Math.abs(v)>=1e6) return (v/1e6).toFixed(2)+'M'; if(Math.abs(v)>=1e3) return (v/1e3).toFixed(2)+'K'; return String(v); }
function malaysiaTime(){ try { return new Intl.DateTimeFormat('en-GB',{timeZone:'Asia/Kuala_Lumpur',year:'numeric',month:'short',day:'numeric',hour:'2-digit',minute:'2-digit',second:'2-digit'}).format(new Date()); } catch(e){ return new Date().toLocaleString(); } }

/* ----------------------------
   Default config & persistence
   ---------------------------- */
const defaultCfg = {
  indicators: {
    'Fear and Greed Index': true,
    'Funding Rate (BTC & ETH average)': true,
    'Bitcoin Dominance (%)': true,
    'Altcoin Season Index': true,
    'Liquidity Ratio (Mcap / Stablecoins)': true,
    'Ethereum Gas (Gwei)': true,
    'RSI (14) on BTC hourly': true,
    'Open Interest (avg BTC & ETH)': true,
    'Volume Change % (24h)': true
  },
  weights: {
    'Fear and Greed Index': 0.20,
    'Funding Rate (BTC & ETH average)': 0.10,
    'Bitcoin Dominance (%)': 0.10,
    'Altcoin Season Index': 0.08,
    'Liquidity Ratio (Mcap / Stablecoins)': 0.08,
    'Ethereum Gas (Gwei)': 0.04,
    'RSI (14) on BTC hourly': 0.20,
    'Open Interest (avg BTC & ETH)': 0.10,
    'Volume Change % (24h)': 0.10
  },
  alert: { bullish_threshold:60, bearish_threshold:40, required_align:3 },
  etherscan_key: 'demo'
};
function loadCfg(){ try{ const raw = localStorage.getItem('csd_v12_cfg'); if(!raw) return JSON.parse(JSON.stringify(defaultCfg)); const p = JSON.parse(raw); p.indicators = {...defaultCfg.indicators, ...(p.indicators||{})}; p.weights = {...defaultCfg.weights, ...(p.weights||{})}; p.alert = {...defaultCfg.alert, ...(p.alert||{})}; p.etherscan_key = p.etherscan_key || defaultCfg.etherscan_key; return p; }catch(e){ return JSON.parse(JSON.stringify(defaultCfg)); } }
function saveCfg(c){ localStorage.setItem('csd_v12_cfg', JSON.stringify(c)); }
let cfg = loadCfg();

/* ----------------------------
   Data fetchers
   ---------------------------- */
async function fetchFNG(d=14){ const r = await safeFetch(`https://api.alternative.me/fng/?limit=${d}`); return r?.data?.map(x=>({value:+x.value,label:x.value_classification,date:+x.timestamp*1000})).reverse()||null; }
async function fetchGlobal(){ const r = await safeFetch('https://api.coingecko.com/api/v3/global'); if(!r?.data) return null; const d=r.data; const stable=(d.total_market_cap.usdt||0)+(d.total_market_cap.usdc||0)+(d.total_market_cap.busd||0)+(d.total_market_cap.dai||0)+(d.total_market_cap.tusd||0); return { btcDom: d.market_cap_percentage?.btc ?? null, totalMcap: d.total_market_cap?.usd ?? null, stablecoins: stable }; }
async function fetchFunding(){ const b1 = await safeFetch('https://fapi.binance.com/fapi/v1/fundingRate?symbol=BTCUSDT&limit=3'); const b2 = await safeFetch('https://fapi.binance.com/fapi/v1/fundingRate?symbol=ETHUSDT&limit=3'); if(!b1||!b2) return null; const avg = arr => arr.reduce((s,i)=>s+parseFloat(i.fundingRate),0)/arr.length; const btc = avg(b1)*100, eth = avg(b2)*100; return { btcAvg:btc, ethAvg:eth, avgBoth:(btc+eth)/2 }; }
async function fetchAlt(){ const r = await safeFetch('https://api.blockchaincenter.net/api/altcoinseason'); if(!r) return Math.floor(Math.random()*100); return r.altcoinSeasonValue ?? r.altcoinSeasonIndex ?? r.altcoinSeason ?? Math.floor(Math.random()*100); }
async function fetchEthGas(key='demo'){ const r = await safeFetch(`https://api.etherscan.io/api?module=gastracker&action=gasoracle&apikey=${key}`); if(!r||!r.result) return 50; return +r.result.ProposeGasPrice; }
async function fetchRSI(p=14){ const r = await safeFetch('https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=3&interval=hourly'); if(!r||!r.prices) return null; const prices=r.prices.map(p=>p[1]); if(prices.length<p+1) return null; function computeRSI(arr,len){ let gains=0,losses=0; for(let i=1;i<=len;i++){ const d=arr[i]-arr[i-1]; if(d>0) gains+=d; else losses+=Math.abs(d);} let avgG=gains/len, avgL=losses/len; for(let i=len+1;i<arr.length;i++){ const d=arr[i]-arr[i-1]; avgG=(avgG*(len-1)+(d>0?d:0))/len; avgL=(avgL*(len-1)+(d<0?Math.abs(d):0))/len;} const rs = avgL===0?1000:(avgG/avgL); return 100 - (100/(1+rs)); } const rsi=computeRSI(prices.slice(-(p+20)),p); return +rsi.toFixed(2); }
async function fetchOpenInterest(){ const b1 = await safeFetch('https://fapi.binance.com/fapi/v1/openInterest?symbol=BTCUSDT'); const b2 = await safeFetch('https://fapi.binance.com/fapi/v1/openInterest?symbol=ETHUSDT'); if(!b1||!b2) return null; const btc=+b1.openInterest, eth=+b2.openInterest; return { btcOI:btc, ethOI:eth, avgOI:(btc+eth)/2 }; }
async function fetchVolChange(){ const r = await safeFetch('https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=3&interval=daily'); if(!r||!r.total_volumes) return null; const vols=r.total_volumes.map(v=>v[1]); if(vols.length<2) return null; const last=vols[vols.length-1], prev=vols[vols.length-2]; const pct = prev===0?0:((last-prev)/prev)*100; return +pct.toFixed(2); }

/* ----------------------------
   Scoring heuristics
   ---------------------------- */
function scoreFNG(v){ if(v==null) return 50; return Math.max(0,Math.min(100,v)); }
function scoreFunding(f){ if(f==null) return 50; const s = 50 - (f*50); return Math.max(0,Math.min(100,s)); }
function scoreBTCdom(b){ if(b==null) return 50; const s = 100 - Math.abs(b-50)*2; return Math.max(0,Math.min(100,s)); }
function scoreAlt(v){ if(v==null) return 50; return Math.max(0,Math.min(100,v)); }
function scoreLiquidity(r){ if(r==null) return 50; const s = 100 - Math.min(100,r); return Math.max(0,Math.min(100,s)); }
function scoreEthGas(g){ if(g==null) return 50; const s = Math.max(0,Math.min(100,100 - Math.min(200,g)/2)); return s; }
function scoreRSI(rsi){ if(rsi==null) return 50; if(rsi<=30) return Math.min(100,80+(30-rsi)); if(rsi>=70) return Math.max(0,20-(rsi-70)); return Math.max(0,Math.min(100,60-((rsi-50)*0.8))); }
function scoreOI(avg){ if(avg==null) return 50; const val=Math.log10(avg+1); const s = Math.max(0,Math.min(100,100-(val*12))); return s; }
function scoreVol(pct){ if(pct==null) return 50; const capped=Math.max(-100,Math.min(100,pct)); return Math.round(50 + (capped/2)); }

/* ----------------------------
   Composite helpers & normalization
   ---------------------------- */
function normalizeWeights(weights, enabledMap){
  const keys = Object.keys(weights).filter(k=>enabledMap[k]);
  let sum=0; keys.forEach(k=> sum += Math.max(0, weights[k]||0));
  if(sum===0){ const out={}; keys.forEach(k=> out[k]=1/keys.length); return out; }
  const out={}; keys.forEach(k=> out[k] = (weights[k]||0)/sum); return out;
}
function computeComposite(scoresMap){
  const normalized = normalizeWeights(cfg.weights, cfg.indicators);
  let total=0;
  Object.keys(normalized).forEach(k=>{
    const sObj = scoresMap[k]; const s = sObj ? (sObj.score||50) : 50;
    total += s * normalized[k];
  });
  return total;
}

/* ----------------------------
   UI: settings build & interactions
   ---------------------------- */
const settingsContent = document.getElementById('settingsContent');
function buildSettings(){
  settingsContent.innerHTML = '';
  Object.keys(cfg.indicators).forEach(key=>{
    const row = document.createElement('div'); row.className='settings-row';
    const left = document.createElement('div'); left.style.display='flex'; left.style.alignItems='center'; left.style.gap='8px';
    const chk = document.createElement('input'); chk.type='checkbox'; chk.checked = !!cfg.indicators[key];
    chk.addEventListener('change', e=>{ cfg.indicators[key] = e.target.checked; saveCfg(cfg); });
    const lbl = document.createElement('label'); lbl.textContent = key; lbl.style.fontWeight='700';
    left.appendChild(chk); left.appendChild(lbl);
    const right = document.createElement('div'); right.style.display='flex'; right.style.alignItems='center'; right.style.gap='8px';
    const slider = document.createElement('input'); slider.type='range'; slider.min='0'; slider.max='100'; slider.value = Math.round((cfg.weights[key]||0)*100);
    slider.addEventListener('input', e=>{ cfg.weights[key] = Number(e.target.value)/100; saveCfg(cfg); pct.textContent = Math.round(Number(e.target.value)) + '%'; });
    const pct = document.createElement('div'); pct.className='small'; pct.textContent = Math.round((cfg.weights[key]||0)*100) + '%';
    right.appendChild(slider); right.appendChild(pct);
    row.appendChild(left); row.appendChild(right);
    settingsContent.appendChild(row);
  });
  // etherscan key
  const rowK = document.createElement('div'); rowK.className='settings-row';
  const lblK = document.createElement('label'); lblK.textContent = 'Etherscan API Key (optional)'; lblK.style.fontWeight='700';
  const inputK = document.createElement('input'); inputK.type='text'; inputK.value = cfg.etherscan_key || ''; inputK.style.padding='6px'; inputK.style.border='1px solid rgba(0,0,0,0.06)'; inputK.style.borderRadius='6px';
  inputK.addEventListener('change', e=>{ cfg.etherscan_key = e.target.value || 'demo'; saveCfg(cfg); });
  rowK.appendChild(lblK); rowK.appendChild(inputK);
  settingsContent.appendChild(rowK);
}

/* ----------------------------
   Render cards, summary, alerts
   ---------------------------- */
function trendText(key, raw){
  const k = 'trend_v12_' + key;
  const prev = parseFloat(localStorage.getItem(k));
  localStorage.setItem(k, raw===null||raw===undefined?NaN:raw);
  if(isNaN(prev)) return '‚ûñ';
  const diff = (raw||0) - prev;
  if(Math.abs(diff) < 1e-8) return '‚ûñ';
  return diff>0 ? 'üìà' : 'üìâ';
}
function suggestLabel(score){
  if(score >= 65) return ['Buy / Accumulate','buy','Oversold or supportive conditions ‚Äî accumulation recommended with risk management.'];
  if(score <= 35) return ['Sell / Exit','sell','Overbought or deteriorating conditions ‚Äî consider reducing exposure.'];
  return ['Hold / Observe','hold','Neutral conditions ‚Äî monitor for clearer signals.'];
}
function renderSummary(actionMap){
  const container = document.getElementById('summary'); container.innerHTML = ''; container.style.display = 'block';
  Object.keys(actionMap).forEach(k=>{
    const r = document.createElement('div'); r.className='summary-row ' + (actionMap[k].type==='buy'?'buy':actionMap[k].type==='sell'?'sell':'hold');
    r.innerHTML = `<div>${k}</div><div>${actionMap[k].label}</div>`;
    container.appendChild(r);
  });
}
function renderAlerts(res){
  const area = document.getElementById('alertArea'); area.innerHTML = '';
  if(res.triggerBull){
    const el = document.createElement('div'); el.className='card'; el.style.background='rgba(29,161,84,0.06)'; el.style.color='#1e8a3f'; el.style.fontWeight=800; el.style.textAlign='center'; el.style.margin='6px 0'; el.textContent = `Bullish alignment ‚Äî ${res.bullish} indicators aligned (>= ${cfg.alert.required_align})`; area.appendChild(el);
  } else if(res.triggerBear){
    const el = document.createElement('div'); el.className='card'; el.style.background='rgba(214,69,58,0.06)'; el.style.color='#d6453a'; el.style.fontWeight=800; el.style.textAlign='center'; el.style.margin='6px 0'; el.textContent = `Bearish alignment ‚Äî ${res.bearish} indicators aligned (>= ${cfg.alert.required_align})`; area.appendChild(el);
  }
}

/* ----------------------------
   Main load, compute, render pipeline
   ---------------------------- */
let mainChart = null;
function renderMainChart(labels, values){
  const ctx = document.getElementById('mainChart').getContext('2d');
  if(mainChart) mainChart.destroy();
  mainChart = new Chart(ctx, { type:'line', data:{ labels, datasets:[{ data: values, borderWidth:2, tension:0.3, pointRadius:1 }]}, options:{responsive:true,maintainAspectRatio:false,plugins:{legend:{display:false}},scales:{y:{beginAtZero:true,max:100}}}});
}

async function loadAndRender(){
  document.getElementById('sentScore').textContent = 'Loading‚Ä¶';
  const en = cfg.indicators;
  const promises = [
    en['Fear and Greed Index'] ? fetchFNG(14) : Promise.resolve(null),
    (en['Bitcoin Dominance (%)'] || en['Liquidity Ratio (Mcap / Stablecoins)']) ? fetchGlobal() : Promise.resolve(null),
    en['Funding Rate (BTC & ETH average)'] ? fetchFunding() : Promise.resolve(null),
    en['Altcoin Season Index'] ? fetchAlt() : Promise.resolve(null),
    en['Ethereum Gas (Gwei)'] ? fetchEthGas(cfg.etherscan_key) : Promise.resolve(null),
    en['RSI (14) on BTC hourly'] ? fetchRSI(14) : Promise.resolve(null),
    en['Open Interest (avg BTC & ETH)'] ? fetchOpenInterest() : Promise.resolve(null),
    en['Volume Change % (24h)'] ? fetchVolChange() : Promise.resolve(null)
  ];
  const [fngData, globalData, fundingData, alt, gas, rsi, oi, volchg] = await Promise.all(promises);

  // build raw values
  const fngLatest = fngData && fngData.length ? fngData[fngData.length-1].value : null;
  const fngLabel = fngData && fngData.length ? fngData[fngData.length-1].label : '';
  const btcDom = globalData ? globalData.btcDom : null;
  const totalMcap = globalData ? globalData.totalMcap : null;
  const stable = globalData ? globalData.stablecoins : null;
  const fundingAvg = fundingData ? fundingData.avgBoth : null;
  const liquidityRatio = (totalMcap && stable) ? (totalMcap / Math.max(1, stable)) : null;

  // compute scores map
  const scores = {};
  scores['Fear and Greed Index'] = { raw: fngLatest, score: scoreFNG(fngLatest), disp: fngLatest!=null? fngLatest + '/100' : 'N/A', meaning: 'Measures market psychology using volatility, volume & social metrics.' , insight: fngLabel ? (fngLabel + ' ‚Äî ' + (fngLatest>=70? 'High optimism; possible overheat.' : fngLatest<=30? 'High fear; possible buying opportunity.' : 'Neutral.')) : '' };
  scores['Funding Rate (BTC & ETH average)'] = { raw: fundingAvg, score: scoreFunding(fundingAvg), disp: fundingAvg!=null? fundingAvg.toFixed(4)+'%' : 'N/A', meaning:'Perpetual futures funding; shows trader bias (longs vs shorts).', insight: fundingAvg!=null? (fundingAvg>0? 'Longs paying ‚Äî bullish but can be over-levered.' : 'Shorts paying ‚Äî bearish bias; possible squeeze risk.') : '' };
  scores['Bitcoin Dominance (%)'] = { raw: btcDom, score: scoreBTCdom(btcDom), disp: btcDom!=null? btcDom.toFixed(2)+'%' : 'N/A', meaning:'% of total market cap in Bitcoin; indicates capital concentration.', insight: btcDom!=null? (btcDom>55? 'BTC-focused market; alt weakness.' : btcDom<45? 'Altcoin rotation; risk-on.' : 'Balanced market.') : '' };
  scores['Altcoin Season Index'] = { raw: alt, score: scoreAlt(alt), disp: alt!=null? Math.round(alt) + '/100' : 'N/A', meaning:'Measures altcoins vs BTC performance over time (BlockchainCenter).', insight: alt!=null? (alt>=75? 'Altcoin season ‚Äî alts outperforming.' : alt<=25? 'Bitcoin-led season.' : 'Mixed rotation.') : '' };
  scores['Liquidity Ratio (Mcap / Stablecoins)'] = { raw: liquidityRatio, score: scoreLiquidity(liquidityRatio), disp: liquidityRatio!=null? liquidityRatio.toFixed(2) : 'N/A', meaning:'Total market cap divided by stablecoin market cap ‚Äî proxy for buying power.', insight: liquidityRatio!=null? (liquidityRatio<10? 'Strong stablecoin liquidity available.' : 'Lower buying power; watch volatility.') : '' };
  scores['Ethereum Gas (Gwei)'] = { raw: gas, score: scoreEthGas(gas), disp: gas!=null? gas + ' Gwei' : 'N/A', meaning:'Average gas price on Ethereum ‚Äî indicates network activity/congestion.', insight: gas!=null? (gas>100? 'High congestion ‚Äî costly txs; FOMO possible.' : gas<20? 'Calm network; cheaper txs.' : 'Moderate activity.') : '' };
  scores['RSI (14) on BTC hourly'] = { raw: rsi, score: scoreRSI(rsi), disp: rsi!=null? rsi.toFixed(2) : 'N/A', meaning:'Relative Strength Index; measures overbought/oversold momentum.', insight: rsi!=null? (rsi<30? 'Oversold ‚Äî potential buy signal.' : rsi>70? 'Overbought ‚Äî caution.' : 'Neutral momentum.') : '' };
  scores['Open Interest (avg BTC & ETH)'] = { raw: oi ? oi.avgOI : null, score: scoreOI(oi?oi.avgOI:null), disp: oi && oi.avgOI ? fmtNum(oi.avgOI) : 'N/A', meaning:'Amount of leveraged positions in futures ‚Äî risk/leveraging indicator.', insight: oi && oi.avgOI ? (oi.avgOI>1e8? 'High leverage ‚Äî liquidation risk.' : 'Moderate leverage.') : '' };
  scores['Volume Change % (24h)'] = { raw: volchg, score: scoreVol(volchg), disp: volchg!=null? volchg + '%' : 'N/A', meaning:'24h trading volume change vs previous 24h ‚Äî trend confirmation.', insight: volchg!=null? (volchg>20? 'Volume rising ‚Äî trend supported.' : volchg<-20? 'Volume falling ‚Äî weak trend.' : 'Stable volume.') : '' };

  // composite
  const composite = computeComposite(scores);

  // chart (prefer FNG), else RSI
  if(fngData && fngData.length){ renderMainChart(fngData.map(d=>new Date(d.date).toLocaleDateString()), fngData.map(d=>d.value)); }
  else if(scores['RSI (14) on BTC hourly'].raw !== null){ renderMainChart(['RSI'], [scores['RSI (14) on BTC hourly'].score]); }

  // render cards
  const order = ['Fear and Greed Index','Funding Rate (BTC & ETH average)','Bitcoin Dominance (%)','Altcoin Season Index','Liquidity Ratio (Mcap / Stablecoins)','Ethereum Gas (Gwei)','RSI (14) on BTC hourly','Open Interest (avg BTC & ETH)','Volume Change % (24h)'];
  const container = document.getElementById('cards'); container.innerHTML=''; const actionMap = {};
  order.forEach(k=>{
    if(!cfg.indicators[k]) return;
    const obj = scores[k]; if(!obj) return;
    const [label, type, tip] = suggestLabel(obj.score);
    actionMap[k] = { label, type, tip };
    const chipClass = type==='buy' ? 'chip buy' : type==='sell' ? 'chip sell' : 'chip hold';
    const bgClass = type==='buy' ? 'buy-bg' : type==='sell' ? 'sell-bg' : 'hold-bg';
    const card = document.createElement('div'); card.className = 'card ' + bgClass;
    card.innerHTML = `<div class="label"><div style="font-weight:800">${k}</div><div class="small">${trendText(k,obj.raw)}</div></div>
                      <div class="value">${obj.disp} <span class="conf">¬∑ ${Math.round(obj.score)}%</span></div>
                      <div class="${chipClass}">${label}</div>
                      <div class="meaning"><b>Meaning:</b> ${obj.meaning || ''}</div>
                      <div class="insight"><b>Insight:</b> ${obj.insight || tip}</div>`;
    container.appendChild(card);
  });

  // composite card
  const compCard = document.createElement('div'); compCard.className='card';
  const compAction = composite>=70 ? ['Sell / Exit','sell','Consider taking profits ‚Äî market showing strong greed.'] : composite<=40 ? ['Buy / Accumulate','buy','Composite indicates buying opportunity (fear).'] : ['Hold / Observe','hold','Composite neutral ‚Äî wait for confirmation.'];
  const compChip = compAction[1]==='buy' ? 'chip buy' : compAction[1]==='sell' ? 'chip sell' : 'chip hold';
  compCard.innerHTML = `<div class="label"><div style="font-weight:800">Composite Sentiment</div><div class="small">${trendText('composite', composite)}</div></div>
                       <div class="value">${composite.toFixed(1)} / 100 <span class="conf">¬∑ composite</span></div>
                       <div class="${compChip}">${compAction[0]}</div>
                       <div class="meaning"><b>Meaning:</b> A weighted blend of enabled indicators providing a single market confidence score (0-100).</div>
                       <div class="insight"><b>Insight:</b> ${compAction[2]}</div>`;
  container.appendChild(compCard);

  // summary & alerts
  renderSummary(actionMap);
  const al = checkAlerts(scores); renderAlerts(al);

  // update header bar & timestamp
  document.getElementById('sentScore').innerHTML = `üß≠ Composite: <strong>${composite.toFixed(1)} / 100</strong> ‚Äî ${mood(composite)}`;
  document.getElementById('ptr').style.left = Math.max(0, Math.min(100, composite)) + '%';
  document.getElementById('timestamp').textContent = '‚è∞ Last updated: ' + malaysiaTime();
}

/* ----------------------------
   Alerts, trend, small helpers
   ---------------------------- */
function checkAlerts(scores){
  let bullish=0, bearish=0;
  const bT = cfg.alert.bullish_threshold, brT = cfg.alert.bearish_threshold;
  Object.keys(cfg.indicators).forEach(k=>{ if(!cfg.indicators[k]) return; const s = scores[k] ? scores[k].score : 50; if(s>=bT) bullish++; if(s<=brT) bearish++; });
  return { bullish, bearish, triggerBull: bullish>=cfg.alert.required_align, triggerBear: bearish>=cfg.alert.required_align };
}
function trendText(key, raw){
  const k = 'trend_v12_' + key; const prev = parseFloat(localStorage.getItem(k)); localStorage.setItem(k, raw===null||raw===undefined?NaN:raw); if(isNaN(prev)) return '‚ûñ'; const diff = (raw||0)-prev; if(Math.abs(diff)<1e-8) return '‚ûñ'; return diff>0 ? 'üìà' : 'üìâ';
}
function suggestLabel(score){
  if(score>=65) return ['Buy / Accumulate','buy','Accumulation recommended with position sizing.'];
  if(score<=35) return ['Sell / Exit','sell','Consider trimming / exiting positions to protect gains.'];
  return ['Hold / Observe','hold','Monitor for clearer signals before acting.'];
}
function mood(score){ if(score<25) return 'üò± Extreme Fear'; if(score<45) return 'üòü Fear'; if(score<60) return 'üòê Neutral'; if(score<75) return 'üòä Greed'; return 'üöÄ Extreme Greed'; }

/* ----------------------------
   Interactions, initialization
   ---------------------------- */
document.getElementById('settingsToggle').addEventListener('click', ()=>{ const p=document.getElementById('settingsPanel'); if(p.style.display==='none'||!p.style.display){ buildSettings(); p.style.display='block'; } else p.style.display='none'; });
document.getElementById('closeSettings').addEventListener('click', ()=>{ document.getElementById('settingsPanel').style.display='none'; loadAndRender(); });
document.getElementById('resetDefaults').addEventListener('click', ()=>{ cfg = JSON.parse(JSON.stringify(defaultCfg)); saveCfg(cfg); buildSettings(); loadAndRender(); });
document.getElementById('refreshNow').addEventListener('click', ()=> loadAndRender());
document.getElementById('darkToggle').addEventListener('click', ()=> document.body.classList.toggle('dark'));
document.getElementById('refresh').addEventListener('change', ()=>{ const m=Number(document.getElementById('refresh').value); if(window.__csd_timer) clearInterval(window.__csd_timer); window.__csd_timer = setInterval(loadAndRender, m*60*1000); localStorage.setItem('csd_v12_refresh', m); });
const savedM = Number(localStorage.getItem('csd_v12_refresh')||10); document.getElementById('refresh').value = savedM; if(window.__csd_timer) clearInterval(window.__csd_timer); window.__csd_timer = setInterval(loadAndRender, savedM*60*1000);

/* ----------------------------
   Start
   ---------------------------- */
buildSettings();
loadAndRender();
</script>
</body>
</html>
